/*
    SQLToolKit/Unit
	Copyright Federico Razzoli 2012
	
	This file is part of SQLToolKit/Unit.
	
    SQLToolKit/Unit is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, version 3 of the License.
	
    SQLToolKit/Unit is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.
	
    You should have received a copy of the GNU Affero General Public License
    along with SQLToolKit/Unit.  If not, see <http://www.gnu.org/licenses/>.
*/


DELIMITER ||


-- create & select db
CREATE DATABASE IF NOT EXISTS `test_stk_unit`;
USE `test_stk_unit`;


DROP TABLE IF EXISTS `run_routine`;
CREATE TABLE `run_routine`
(
	`name` CHAR(50) NOT NULL
)
	ENGINE   = 'MEMORY',
	DEFAULT CHARACTER SET = ascii,
	COLLATE = ascii_bin,
	COMMENT = 'Test data';



DROP PROCEDURE IF EXISTS `before_all_tests`;
CREATE PROCEDURE before_all_tests()
	LANGUAGE SQL
	COMMENT 'Test that before_all_tests() is called'
BEGIN
	TRUNCATE TABLE `run_routine`;
	INSERT HIGH_PRIORITY INTO `run_routine` (`name`) VALUES ('before_all_tests');
END;

DROP PROCEDURE IF EXISTS `set_up`;
CREATE PROCEDURE set_up()
	LANGUAGE SQL
	COMMENT 'Test that set_up() is called'
BEGIN
	INSERT HIGH_PRIORITY INTO `run_routine` (`name`) VALUES ('set_up');
END;

DROP PROCEDURE IF EXISTS `tear_down`;
CREATE PROCEDURE tear_down()
	LANGUAGE SQL
	COMMENT 'Test that tear_down() is called'
BEGIN
	INSERT HIGH_PRIORITY INTO `run_routine` (`name`) VALUES ('tear_down');
END;

DROP PROCEDURE IF EXISTS `after_all_tests`;
CREATE PROCEDURE after_all_tests()
	LANGUAGE SQL
	COMMENT 'Test that after_all_tests() is called'
BEGIN
	INSERT HIGH_PRIORITY INTO `run_routine` (`name`) VALUES ('after_all_tests');
END;

DROP PROCEDURE IF EXISTS `test_a`;
CREATE PROCEDURE test_a()
	LANGUAGE SQL
	COMMENT 'First. Triggers setup & teardown'
BEGIN
	DO NULL;
END;

DROP PROCEDURE IF EXISTS `test_setup_teardown`;
CREATE PROCEDURE test_setup_teardown()
	LANGUAGE SQL
	COMMENT 'Test set_up tear_down before/after_all_tests'
BEGIN
	CALL `stk_unit`.assert_true(
			(SELECT COUNT(*) > 0 FROM `run_routine` WHERE `name` = 'set_up'),
			'set_up() not executed'
		);
	CALL `stk_unit`.assert_true(
			(SELECT COUNT(*) > 0 FROM `run_routine` WHERE `name` = 'tear_down'),
			'tear_down() not executed'
		);
	CALL `stk_unit`.assert_true(
			(SELECT COUNT(*) > 0 FROM `run_routine` WHERE `name` = 'before_all_tests'),
			'before_all_tests() not executed'
		);
	/*
		How can we test this?
	CALL `stk_unit`.assert_true(
			(SELECT COUNT(*) > 0 FROM `run_routine` WHERE `name` = 'after_all_tests'),
			'after_all_tests() not executed'
		);
	*/
END;

DROP PROCEDURE IF EXISTS `test_config_set_get`;
CREATE PROCEDURE test_config_set_get()
	LANGUAGE SQL
	COMMENT 'Test config_set(), config_get()'
BEGIN
	DECLARE `res` TEXT;
	DECLARE `val` TEXT;
	DECLARE `zero` CHAR(1) DEFAULT '0';
	DECLARE `unus` CHAR(1) DEFAULT '1';
	
	-- set & get valid option
	CALL `stk_unit`.`config_set`('show_err', `zero`);
	SET `res` = `stk_unit`.`config_get`('show_err');
	CALL `stk_unit`.`assert_equals`(`res`, `zero`,
		CONCAT('Incorrect option value; should be ', IFNULL(`zero`, 'NULL'), ', got: ', IFNULL(`res`, 'NULL')));
	
	-- change & read again same option
	CALL `stk_unit`.`config_set`('show_err', `unus`);
	SET `res` = `stk_unit`.`config_get`('show_err');
	CALL `stk_unit`.`assert_equals`(`res`, `unus`,
		CONCAT('Incorrect option value; should be ', IFNULL(`unus`, 'NULL'), ', got: ', IFNULL(`res`, 'NULL')));
END;

DROP PROCEDURE IF EXISTS `test_config_set_invalid`;
CREATE PROCEDURE test_config_set_invalid()
	LANGUAGE SQL
	COMMENT 'Test config_set()'
BEGIN
	-- try to set invalid option
	/*M!50500
		CALL `stk_unit`.`expect_any_exception`();
	*/
	CALL `stk_unit`.`config_set`('not-exists', '1');
END;

DROP PROCEDURE IF EXISTS `test_log_result`;
CREATE PROCEDURE test_log_result()
	LANGUAGE SQL
	COMMENT 'Test log_result()'
BEGIN
	-- number of "artificial" test results
	DECLARE num_entries_art  BIGINT UNSIGNED     DEFAULT NULL;
	-- identifies an "artificial" test result, created by the test
	DECLARE test_note        CHAR(50)            DEFAULT 'Intentionally generated by the test';
	
	-- delete "artificial" results
	-- (yes, we have to do this before AND after)
	DELETE
		FROM `stk_unit`.`test_results`
		WHERE `msg` = test_note;
	
	-- insert "artificial" results
	CALL `stk_unit`.log_result('pass',       test_note);
	CALL `stk_unit`.log_result('fail',       test_note);
	CALL `stk_unit`.log_result('exception',  test_note);
	
	-- "artificial" results must be 3
	SELECT COUNT(*)
		FROM `stk_unit`.`test_results`
		WHERE `msg` = test_note
		INTO `num_entries_art`;
	CALL `stk_unit`.assert_true(num_entries_art = 3, CONCAT('Created entries: ', num_entries_art, ' instead of 3'));
	
	-- delete "artificial" results
	DELETE
		FROM `stk_unit`.`test_results`
		WHERE `msg` = test_note;
END;

DROP PROCEDURE IF EXISTS `test_expect`;
CREATE PROCEDURE test_expect()
	LANGUAGE SQL
	COMMENT 'Test ignore_all_exceptions(), expect_any_exception()'
BEGIN
	DECLARE num_entries TINYINT UNSIGNED DEFAULT NULL;
	
	CALL `stk_unit`.ignore_all_exceptions();
	SELECT COUNT(*) FROM `stk_unit`.`expect` INTO num_entries;
	CALL `stk_unit`.assert_true(num_entries = 1, CONCAT('Created entries: ', num_entries, ' instead of 1'));
	
	CALL `stk_unit`.clean_expect();
	SELECT COUNT(*) FROM `stk_unit`.`expect` INTO num_entries;
	CALL `stk_unit`.assert_true(num_entries = 0, CONCAT('Expectations of type ignore not cleaned'));
	
	CALL `stk_unit`.expect_any_exception();
	SELECT COUNT(*) FROM `stk_unit`.`expect` INTO num_entries;
	CALL `stk_unit`.assert_true(num_entries = 1, CONCAT('Created entries: ', num_entries, ' instead of 1'));
	
	CALL `stk_unit`.clean_expect();
	SELECT COUNT(*) FROM `stk_unit`.`expect` INTO num_entries;
	CALL `stk_unit`.assert_true(num_entries = 0, CONCAT('Expectations of type expect not cleaned'));
END;

||

DELIMITER ;


